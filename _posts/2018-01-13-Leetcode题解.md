---
layout: post
title: Leetcode题解
tags: [算法, Leetcode]
category: Algorithm
#eye_catch: http://jekyllrb.com/img/logo-2x.png
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 1. Two Sum

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

```markdown
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

<!--more-->
<!--more-->

- 暴力求解. O(n^2)

```markdown
two-sum(A, key):
for i=1 to A.length-1
    for j=i+1 to A.length
        if A[i] + A[j] = key
            return [i,j]
```

- HashMap保存数组的元素和索引, 遍历过程在map中找(key-A[i]), 若存在则返回[i, map.get(key-A[i])]. O(n)

```java
private static int[] findTwoSum(int[] arr, int key) {
    Map<Integer, Integer> map = new HashMap<>(arr.length);
    for (int i = 0; i < arr.length; i++) {
        if (map.containsKey(key - arr[i])) {
            return new int[]{map.get(key - arr[i]), i};
        }
        map.put(arr[i], i);
    }
    throw new RuntimeException("No two sum solution");
}
```

--------

## 2. Maximum Subarray

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

- 线性时间算法. O(n)

curSum记录每次迭代的最大和
```java
private static int maxSubArray(int[] arr) {
    if (arr.length == 1) return arr[0];
        
    int max = arr[0], curSum = arr[0];
    for (int i = 1; i < arr.length; i++) {
        curSum = Math.max(curSum + arr[i], arr[i]);
        max = Math.max(max, curSum);
    }
    return max;
}
```

- 分治算法. O(nlg n)

```java
private static int maxSubArrayDivide(int[] arr, int left, int right) {
    if (left >= right) {
        return arr[left];
    }

    int mid = left + ((right - left) >> 1);
    int leftSum = maxSubArrayDivide(arr, left, mid);
    int rightSum = maxSubArrayDivide(arr, mid + 1, right);
    int crossSum = crossMiddle(arr, left, mid, right);

    return Math.max(leftSum, Math.max(rightSum, crossSum));
}

private static int crossMiddle(int[] arr, int left, int mid, int right) {
    int sum = 0, leftMax = Integer.MIN_VALUE, rightMax = Integer.MIN_VALUE;
    for (int i = mid; i >= left; i--) {
        sum += arr[i];
        if (sum > leftMax) {
            leftMax = sum;
        }
    }

    sum = 0;
    for (int i = mid + 1; i <= right; i++) {
        sum += arr[i];
        if (sum > rightMax) {
            rightMax = sum;
        }
    }
    return leftMax + rightMax;
}
```
