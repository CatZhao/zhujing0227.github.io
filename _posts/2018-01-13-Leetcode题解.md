---
layout: post
title: Leetcode题解
tags: [算法, Leetcode]
category: Algorithm
#eye_catch: http://jekyllrb.com/img/logo-2x.png
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 1. Two Sum

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

```markdown
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

<!--more-->
<!--more-->

- 暴力求解. O(n^2)

```markdown
two-sum(A, key):
for i=1 to A.length-1
    for j=i+1 to A.length
        if A[i] + A[j] = key
            return [i,j]
```

- HashMap保存数组的元素和索引, 遍历过程在map中找(key-A[i]), 若存在则返回[i, map.get(key-A[i])]. O(n)

```java
private static int[] findTwoSum(int[] arr, int key) {
    Map<Integer, Integer> map = new HashMap<>(arr.length);
    for (int i = 0; i < arr.length; i++) {
        if (map.containsKey(key - arr[i])) {
            return new int[]{map.get(key - arr[i]), i};
        }
        map.put(arr[i], i);
    }
    throw new RuntimeException("No two sum solution");
}
```

--------

## 2. Maximum Subarray

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

- 线性时间算法. O(n)

curSum记录每次迭代A[0..i]的最大子数组

```java
private static int maxSubArray(int[] arr) {
    if (arr.length == 1) return arr[0];

    int max = arr[0], curSum = arr[0];
    for (int i = 1; i < arr.length; i++) {
        curSum = Math.max(curSum + arr[i], arr[i]);
        max = Math.max(max, curSum);
    }
    return max;
}
```

- 分治算法. O(nlg n)

最大子数组必定在左半部分/有半部分或跨越中间的, 分别计算三部分的最大子数组, 三者最大值即为最终的最大子数组.

```java
private static int maxSubArrayDivide(int[] arr, int left, int right) {
    if (left >= right) {
        return arr[left];
    }

    int mid = left + ((right - left) >> 1);
    //左半部分最大子数组
    int leftSum = maxSubArrayDivide(arr, left, mid);
    //右半部分最大子数组
    int rightSum = maxSubArrayDivide(arr, mid + 1, right);
    //跨越中点的最大子数组
    int crossSum = crossMiddle(arr, left, mid, right);

    return Math.max(leftSum, Math.max(rightSum, crossSum));
}

private static int crossMiddle(int[] arr, int left, int mid, int right) {
    int sum = 0, leftMax = Integer.MIN_VALUE, rightMax = Integer.MIN_VALUE;
    //从mid出发, 左边最大子数组
    for (int i = mid; i >= left; i--) {
        sum += arr[i];
        if (sum > leftMax) {
            leftMax = sum;
        }
    }

    sum = 0;
    //从mid+1出发右边最大子数组
    for (int i = mid + 1; i <= right; i++) {
        sum += arr[i];
        if (sum > rightMax) {
            rightMax = sum;
        }
    }
    return leftMax + rightMax;
}
```

- 动态规划. O(n)

与线性时间一样, 只是保存了每一步的最大子数组

```java
public static int maxSubArrayDP(int[] arr) {
    //dp[i] means the maximum subarray ending with A[i];
    int[] dp = new int[arr.length];
    dp[0] = arr[0];
    int max = dp[0];

    for(int i = 1; i < arr.length; i++){
        dp[i] = Math.max(arr[i], dp[i-1] + arr[i]);
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

--------

## 3. Unique Paths

A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

- 递归求解

当前位置的结果 = 从当前位置向下走一步的结果 + 与从当前位置向右走一步的结果之和

```java
private static int uniquePathsRecursive(int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    if (m == 1 || n == 1) {
        return 1;
    }
    return uniquePathsRecursive(m, n - 1) + uniquePathsRecursive(m - 1, n);
}
```

- 动态规划 O(m*n)

递归存在大量重复的计算, 动态规划中使用数组保存了之前的计算结果.

```java
private static int uniquePaths(int m, int n) {
    int[][] tab = new int[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                tab[i][j] = 1;
            } else {
                tab[i][j] = tab[i - 1][j] + tab[i][j - 1];
            }
        }
    }
    return tab[m - 1][n - 1];
}
```

DP优化: 空间复杂度从O(m*n)降到O(min(m,n))

```java
private static int uniquePaths(int m, int n){
    //assume m >= n
    if(m < n){
        int t = m;
        m = n;
        n = t;
    }
    int[] tab = new int[n];
    tab[0] = 1;

    for(int i = 0; i < m; i++){
        for(int j = 1; j < n; j++){
            tab[j] += tab[j - 1];
        }
    }
    return tab[n - 1];
}
```

## 4. Kth Largest Element in an Array

Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
For example,
Given [3,2,1,5,6,4] and k = 2, return 5.

- 快排

```java

```

- 最小堆法

用原数组A[0, k-1]构建k个元素的最小堆, 遍历A[k, A.length-1], if(A[0] < A[i]), then swap A[0] with A[i], 维护最小堆的性质, 遍历结束后A[0]即为 Kth Largest Element in an Array.

```java

```

与之类似求 Kth Smallest Element in an Array 可以用最大堆求解